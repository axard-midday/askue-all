#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <ctype.h>
#include <sqlite3.h>
#include <libconfig.h>

#define ASKUE_DB_FILE "./askue.db.sqlite3"

#define ASKUE_NET_CFG_FILE "./askue.net.cfg"

/*
 * Запросы на создание таблиц
 */
// таблица показаний
#define CREATE_REG_TBL "CREATE TABLE IF NOT EXISTS reg_tbl ( cnt INTEGER, value INTEGER, type TEXT, date TEXT, time TEXT );"

// таблица счётчиков
#define CREATE_CNT_TBL "CREATE TABLE IF NOT EXISTS cnt_tbl ( cnt INTEGER, type text, timeout INTEGER, modem TEXT );"

// таблица-маска времени
#define CREATE_TIME_TBL "CREATE TABLE IF NOT EXISTS time_tbl ( time TEXT );"

// таблица модемов
#define CREATE_MODEM_TBL "CREATE TABLE IF NOT EXISTS modem_tbl ( modem TEXT, type text, remote_flag INTEGER );"

/*
 * Запросы на создание индексов
 */
// индекс таблицы показаний
#define CREATE_REG_ID "CREATE UNIQUE INDEX IF NOT EXISTS reg_id ON reg_tbl ( cnt, type, date, time );"

// индекс таблицы счётчиков
#define CREATE_CNT_ID "CREATE UNIQUE INDEX IF NOT EXISTS cnt_id ON cnt_tbl ( cnt, type, modem );"

// индекс таблицы-маски времени
#define CREATE_TIME_ID "CREATE UNIQUE INDEX IF NOT EXISTS time_id ON time_tbl ( time );"

// индекс для таблицы модемов
#define CREATE_MODEM_ID "CREATE UNIQUE INDEX IF NOT EXISTS modem_id ON modem_tbl ( modem, type );"

/*
 * декорирование обращения к базе
 */
int sqlite3_exec_decor ( sqlite3 *db, char *sql, int ( *callback ) ( void*, int, char **, char ** ), void *ptr )
{
	char *sqlite3_emsg = NULL;

        int sqlite3_exec_status = sqlite3_exec ( db, sql, callback, ptr, &sqlite3_emsg ); // выполнить запрос

        if ( sqlite3_exec_status != SQLITE_OK && sqlite3_exec_status != SQLITE_CONSTRAINT ) // если обнаружена ошибка
	{
	       ( *error_msg ) = strdup ( sqlite3_emsg ); // дублировать строку с ошибкой для вывода на уровень выше
			
	        sqlite3_free ( sqlite3_emsg );
	
	        return -1;
	}
	else
	{
	
	        return 0;
	}
} 


/*
 * Получить флаг удалённости
 */
bool_t is_modem_remote ( const config_setting_t *modem )
{
	const char *modem_id = config_setting_name ( modem );
	
        if ( modem_id[ 1 ] == 'R' ) // определить местоположение модема в сети
        {
               return TRUE; // удалённый модем
        }
        else
        {
               return FALSE; // местный модем
        }            
}

/*
 * Получить тип модема
 */
bool_t get_modem_type ( const config_setting_t *modem )
{      
        return config_setting__name ( modem ) + 3; // возврат   
}

/*
 * Добавить счётчик в базу
 */
bool_t askue_network_config_device ( sqlite3 *db, const char *type, const config_setting_t *device, const char *modem_id )
{
	int cnt_id = config_setting_get_int_elem ( device, 0 ); // номер устройства
	       
	int cnt_delay = config_setting_get_int_elem ( device, 1 ); // задержка чтения

	// формирование запроса на добавление данных о счётчике в базу
	char *sql = sqlite3_mprintf ( "INSERT INTO cnt_tbl ( cnt, type, timeout, modem ) VALUES ( %d, '%s', %d, '%s' );", cnt_id, type, cnt_delay, modem_id );
		       
	bool_t status = sqlite3_exec_decor ( db, sql, NULL, NULL );
	
	sqlite3_free ( sql );
	
	return status;
}

/*
 * Добавить модем в базу
 */
bool_t askue_network_config_modem ( sqlite3 *db, const config_setting_t *modem )
{
	const char *modem_id = config_setting_get_string ( modem ); // номер модема
	
	const char *modem_type = get_modem_type ( modem ); // тип модема
	
	int remote_flag = get_modem_remote_flag ( modem ); // определить является ли модем удалённым

       	// формирование запроса на добавление данных о счётчике в базу
        char *sql = sqlite3_mprintf ( "INSERT INTO modem_tbl ( modem, type, remote_flag ) VALUES ( '%s', %d );", modem_id, remote_flag );
               
        bool_t status = sqlite3_exec_decor ( db, sql, NULL, NULL );
	
	sqlite3_free ( sql );
	
	return status;
}

/*
 * Обход списка устройств одного типа
 */
bool_t askue_network_config_device_list ( sqlite3 *db, const config_setting_t *device_list, const char *modem_id )
{
        bool_t status = TRUE;
        
        const char *type = config_setting_name ( device_list ); // тип устройства
        
        size_t length = config_setting_length ( device_list ); // кол-во устройств в списке
        
	for ( size_t i = 0; i < length && status; i++ ) // перебор устройств
	{
	       status = askue_network_config_device ( db, type, config_setting_get_elem ( device_list, i ), modem_id ); // добавить в таблицу устройств
	}
	
	return status;
}

/*
 * Найти модем в ветви
 */
config_setting_t* lookup_plc_modem ( const config_setting_t *branch )
{
        config_setting_t *modem = NULL;

        for ( size_t i = 0; i < config_setting_length ( branch ) && modem == NULL; i++ ) // перебор устройств в сети
	{
		config_setting_t *elem = config_setting_get_elem ( branch, i );
	
		const char *modem_id = config_setting_name ( elem );
	
	        if ( modem_id[ 0 ] == 'm' )
	        {
	                modem = elem;
	        }
	}
	
	return modem;
}

/*
 * Обход ветви
 */
bool_t askue_network_config_branch ( sqlite3 *db, const config_setting_t *branch )
{
        bool_t status = TRUE;
        
        config_setting_t *modem = lookup_plc_modem ( branch ); // поиск модема в ветви
        
        if ( modem != NULL )
        {
                // модем найден
        
                if ( ( status = askue_network_config_modem ( db, modem ) ) ) // записать в таблицу модемов
                {
                	const char *modem_name = config_setting_get_string ( modem ); // имя модема
                	
                	size_t length = config_setting_length ( branch ); // длина ветви
                
		        for ( size_t i = 0; i < length && status; i++ ) // перебор устройств в сети
			{
				config_setting_t *elem = config_setting_get_elem ( branch, i ); // следующий список устройств
			               
			        if ( elem != modem ) // проверить: не пытаемся ли мы записать модем как счётчик
			        	askue_network_config_device_list ( db, elem, modem_name ); // запись в базу устройств одного типа
			}
	        }
	}
	else
	{
	       // модем отсутствует
	       
	       size_t length = config_setting_length ( branch ); // длина ветви
	
	       for ( size_t i = 0; i < length && status; i++ ) // перебор устройств в сети
	       {
	              config_setting_t *elem = config_setting_get_elem ( branch, i ); // следующий список устройств

                      status = traverse_device_list ( db, elem, "" ); // запись в базу устройств одного типа
	       }        
	}
	
	return status;
}

/*
 * Занесение данных из конфига в таблицу базы
 */
int askue_network_config ( sqlite3 *db )
{
	bool_t status = TRUE;
	
        config_t cfg;

	config_init ( &cfg ); // выделить память под переменную с конфигурацией

	if ( config_read_file ( &cfg, ASKUE_NET_CFG_FILE ) == CONFIG_TRUE ) // открыть и прочитать файл
	{
	        config_setting_t *net = config_lookup ( &cfg, "Network" ); // поиск сети
	        
	        if ( net != NULL )
	        {
			size_t length = config_setting_length ( net ); // длина сети
	
			for ( size_t i = 0; i < length && status; i++ )
			{
			        status = askue_network_config_branch ( db, config_setting_get_elem ( net, i ) );
			}
	        }
	        else
	        {
	        	log_write ( stderr, "Отсутствует поле 'Network' в конфигурации\n" );
	        	
	        	status = FALSE;
	        }      
	}
	else
	{
	        log_write ( stderr, "Ошибка конфигурации: %s ( %d )\n", config_error_text ( &cfg ), config_error_line ( &cfg ) );
	        
	        status = FALSE;
	}
	
	config_destroy ( &cfg );
	 
	return status;
}

/*
 * Подготовка базы путём добавления запроса в неё
 */
int db_add_tbl ( sqlite3 *db, const char *_tbl_req, const char *_id_req, char **error_msg )
{
        char *sqlite3_emsg = NULL;

        if ( sqlite3_exec ( db, _tbl_req, NULL, NULL, &sqlite3_emsg ) != SQLITE_OK ) // запрос на создание таблицы
	{
		( *error_msg ) = strdup ( sqlite3_emsg );
			
		sqlite3_free ( sqlite3_emsg );
		
		return -1;
	}
	else
	{
	        if ( _id_req != NULL )
	        {
	                if ( sqlite3_exec ( db, _id_req, NULL, NULL, &sqlite3_emsg ) != SQLITE_OK ) // запрос на создание индекса
	                { 
                                ( *error_msg ) = strdup ( sqlite3_emsg );
			
		                sqlite3_free ( sqlite3_emsg );
		
		                return -1;
		        }
		        else
		        {
		                return 0;
		        }
		}
		else
		{
		        return 0;
		}
	}  
}

/*
 * подготовить таблицу с возможными временами
 */
int time_tbl_prepare ( sqlite3 *db, char **error_msg )
{
        int status = 0;

        for ( unsigned int i = 0; i < 48; i ++ ) // перебор всех получасий
        {
                // формирование запроса на добавление времени в таблицу маску
                char *sql = sqlite3_mprintf ( "INSERT INTO time_tbl ( time ) VALUES ( ( SELECT TIME ( 'now', 'start of day', '+%u minute' ) ) );", i * 30 );
                
                char *sqlite3_emsg = NULL;

                int sqlite3_exec_status = sqlite3_exec ( db, sql, NULL, NULL, &sqlite3_emsg); // выполнить запрос

                if ( sqlite3_exec_status != SQLITE_OK && sqlite3_exec_status != SQLITE_CONSTRAINT ) // если обнаружена ошибка
	        {
		        ( *error_msg ) = strdup ( sqlite3_emsg );
			
		        sqlite3_free ( sqlite3_emsg );
		
		        sqlite3_free ( sql );
		
		        status = -1;
		
		        break;
	        }
	        else
	                sqlite3_free ( sql );
	        
	}
	
	return status;
}

/*
 * Начальная настройка базы
 */
int askue_db_init ( sqlite3 **db, char **error_msg )
{

        if ( sqlite3_open ( ASKUE_DB_FILE, db ) == SQLITE_OK )
        {
                // успех

		// начать транзакции
		if ( sqlite3_exec_decor ( *db, "BEGIN TRANSACTION;", NULL, NULL, error_msg ) == 0 )
		{
			int status = -1;
		
		        // проверка таблиц и индексов
		        if ( !db_add_tbl ( *db, CREATE_REG_TBL, CREATE_REG_ID, error_msg ) &&
		             !db_add_tbl ( *db, CREATE_CNT_TBL, CREATE_CNT_ID, error_msg ) && 
		             !db_add_tbl ( *db, CREATE_MODEM_TBL, CREATE_MODEM_ID, error_msg ) && 
		             !db_add_tbl ( *db, CREATE_TIME_TBL, CREATE_TIME_ID, error_msg ) &&
		             !db_add_tbl ( *db, CREATE_TYPE_TBL, NULL, error_msg ) )
		        {
		                if ( net_tbl_prepare ( *db, error_msg ) == 0 &&
		                     time_tbl_prepare ( *db, error_msg ) == 0 )
		                        status = 0;
		        }
		        sqlite3_exec_decor ( *db, "END TRANSACTION;", NULL, NULL, error_msg );
		        
		        return status;
		}
        }
        else
        {
                // неудача
                
                // сообщить об ошибке
                ( *error_msg ) = strdup ( sqlite3_errmsg ( *db ) );
                return -1;
        }
}

/*
 * 
 */

int main ( int argc, char **argv )
{
        sqlite3 *db;
        
        char *errmsg = NULL;
        
        int st = askue_db_init ( &db, &errmsg );
        
        printf ( "Статус подготовки базы: %d\n", st );
        
        if ( st && errmsg != NULL )
        {
                printf ( "Ошибка при подготовке базы: %s\n", errmsg );
                
                free ( errmsg );
        }
        
        sqlite3_close ( db );
        
        return 0;
}



















